/// @name std
/// The Teo standard library
namespace std {

    /// @name EnvVars
    /// The environment variables
    declare struct EnvVars {
        declare static function new(): Self
        declare function subscript(key?: String): String?
    }

    /// @name ENV
    /// The environment variables
    let ENV = EnvVars()

    declare struct Bool {
        declare static function new(from?: String): Result<Self>
    }

    declare struct String {
        declare static function new(from?: Int | Int64 | Float | Float32 | Bool | ObjectId): Self
    }

    declare struct Int {
        declare static function new(from?: String): Result<Self>
    }

    declare struct Int64 {
        declare static function new(from?: String): Result<Self>
    }

    declare struct Float {
        declare static function new(from?: String): Result<Self>
    }

    declare struct Float32 {
        declare static function new(from?: String): Result<Self>
    }

    declare struct Decimal {
        declare static function new(from?: String): Result<Self>
    }

    declare struct Date {
        declare static function new(from?: String): Result<Self>
    }

    declare struct DateTime {
        declare static function new(from?: String): Result<Self>
    }

    declare struct ObjectId {
        declare static function new(from?: String): Result<Self>
    }

    /// @name Action
    /// Represents the predefined actions
    interface option enum Action {
        create = 1
        update = 1 << 1
        delete = 1 << 2
        find = 1 << 3
        first = 1 << 4
        connect = 1 << 5
        disconnect = 1 << 6
        set = 1 << 7
        join = 1 << 8
        signIn = 1 << 9
        identity = 1 << 10
        count = 1 << 11
        aggregate = 1 << 12
        groupBy = 1 << 13
        programCode = 1 << 14
        upsert = .create | .update
        connectOrCreate = .connect | .create
        joinCreate = .join | .create
        joinDelete = .join | .delete
        findFirst = .find | .first
        entry = 1 << 15
        nested = 1 << 16
        internalPosition = 1 << 17
        single = 1 << 18
        many = 1 << 19
        internalAmount = 1 << 20
    }

    /// @name Sort Order
    /// Represents the sort order
    interface enum Sort {
        asc
        desc
    }

    /// @name Database
    /// Represents the supported database of Teo
    interface enum Database {
        /// @name MongoDB
        /// The MongoDB database    
        mongo
        /// @name MySQL
        /// The MySQL database
        mysql
        /// @name PostgreSQL
        /// The PostgreSQL database
        postgres
        /// @name SQLite
        /// The SQLite database
        sqlite
    }

    /// @name Client Language
    /// The programming langauge of the generated client
    interface enum ClientLanguage {
        /// @name javaScript
        /// The javaScript programming language
        javaScript
        /// @name TypeScript
        /// The TypeScript programming language
        typeScript
        /// @name Swift
        /// The Swift programming language
        swift
        /// @name Kotlin
        /// The Kotlin programming language
        kotlin
        /// @name C#
        /// The C# programming language
        cSharp
        /// @name Dart
        /// The Dart programming language
        dart
    }

    /// @name Runtime
    /// Represents the supported runtime of Teo
    interface enum Runtime {
        /// @name Rust
        /// The rust runtime
        rust
        /// @name Node.js
        /// The Node.js runtime
        node
        /// @name Python
        /// The python runtime
        python
    }

    /// @name Connector
    /// Represents the database connection
    declare config connector {
        /// @name Provider
        /// Represents the type of database this app connects
        provider: Database
        /// @name URL
        /// The URL of the database to connect to
        url: String
    }

    /// @name Server
    /// Define the HTTP server configuration
    declare config server {
        /// @name bind
        /// On which IP and port the HTTP server binds
        bind: (String, Int)
        /// @name path prefix
        /// The request URL path prefix
        pathPrefix: String?
    }

    /// @name Entity Generator
    /// Define an entity generator
    declare config entity {
        /// @name Provider
        /// Which runtime is used for the generated entities
        provider: Runtime
        /// @name Destination
        /// Where the generated entities are places
        dest: String
    }

    /// @name Client Generator
    /// Define a client generator
    declare config client {
        /// @name Provider
        /// Which programming language is used for the generated client
        provider: ClientLanguage
        /// @name Destination
        /// Where the generated client are placed
        dest: String
        /// @name Package
        /// Whether generate code only or a package, defaults to `true`
        package: Bool?
        /// @name Host
        /// The host for the generated client
        host: String
        /// @name Object Name
        /// The main object name for the generated package
        objectName: String?
        /// @name Git Commit
        /// Whether do `git commit` after each generation
        gitCommit: Bool?
    }

    /// @name Map
    /// Specify an underlying database table name for the model
    declare unique model decorator map(table_name?: String)

    /// @name Id
    /// Specify the model's primary index
    declare unique model decorator id(fields?: ScalarField<Self> | ScalarField<Self>[], map?: String?)

    /// @name Index
    /// Add an index to the model
    declare model decorator index(fields?: ScalarField<Self> | ScalarField<Self>[], map?: String?)

    /// @name Unique
    /// Add a unique constraint to the model
    declare model decorator unique(fields?: ScalarField<Self> | ScalarField<Self>[], map?: String?)

    /// @name Migration
    /// Specify the migration operations for the model
    declare unique model decorator migration(renamed: (String | Vec<String>)?, version: String?, drop: Bool?)

    /// @name Before Save
    /// Specify the action to trigger before an object is saved
    declare unique model decorator beforeSave(pipeline?: Pipeline<Object<Self>, Ignored>)

    /// @name After Save
    /// Specify the action to trigger after an object is saved
    declare unique model decorator afterSave(pipeline?: Pipeline<Object<Self>, Ignored>)

    /// @name Before Delete
    /// Specify the action to trigger before an object is deleted
    declare unique model decorator beforeDelete(pipeline?: Pipeline<Object<Self>, Ignored>)

    /// @name After Delete
    /// Specify the action to trigger after an object is deleted
    declare unique model decorator afterDelete(pipeline?: Pipeline<Object<Self>, Ignored>)

    /// @name Can Read
    declare unique model decorator canRead(pipeline?: Pipeline<Object<Self>, Ignored>)

    /// @name Can Mutate
    declare unique model decorator canWrite(pipeline?: Pipeline<Object<Self>, Ignored>)

    /// @name Disable
    /// Specify disabled actions
    declare unique model decorator disable(actions?: Action)

    /// @name Identity
    /// Specify whether the model is used as identity
    declare unique model decorator identity

    /// @name Map
    /// Specify an underlying database column name for the model field
    declare unique model field decorator map(table_name?: String)

    /// @name Database Type
    /// Specify an underlying database type for the model field
    declare unique model field decorator db(type?: DatabaseType<CurrentConnector>)

    /// @name Readonly
    /// Disallow this field to be written by the client
    declare unique model field decorator readonly

    /// @name Writeonly
    /// Disallow this field to be read by the client
    declare unique model field decorator writeonly

    /// @name Internal
    /// Disallow this field to be read or write by the client
    declare unique model field decorator internal

    /// @name Write on Create
    /// This field can only be written on create
    declare unique model field decorator writeOnCreate

    /// @name Write Once
    /// This field can only be written if current value is null
    declare unique model field decorator writeOnce

    /// @name Write Nonnull
    /// This field can only be written if new value is not null
    declare unique model field decorator writeNonNull

    /// @name Read If
    /// This field can be read by the client if the pipeline passes
    declare unique model field decorator readIf(cond?: Pipeline<Object<Self>, Ignored>)

    /// @name Write If
    /// This field can be written by the client if the pipeline passes
    declare unique model field decorator writeIf(cond?: Pipeline<Object<Self>, Ignored>)

    /// @name Read Write
    /// This field can be written and read by the client, this is the default behavior
    declare unique model field decorator readwrite

    /// @name Present With
    /// Specify when some other field are not null, this field is required
    declare unique model field decorator presentWith(fields?: ScalarField<Self> | ScalarField<Self>[])

    /// @name Present Without
    /// Specify when some other field are null, this field is required
    declare unique model field decorator presentWithout(fields?: ScalarField<Self> | ScalarField<Self>[])

    /// @name Present If
    /// Specify when some condition passes, this field is required
    declare unique model field decorator presentIf(cond?: Pipeline<Object<Self>, Ignored>)

    /// @name Atomic
    /// This field can be updated with atomic updator
    declare unique model field decorator atomic

    /// @name Nonatomic
    /// This field cannot be updated with atomic updator
    declare unique model field decorator nonatomic

    /// @name Id
    /// Specify this field as the model's primary index
    declare exclusive model field decorator id(sort: Sort?, length: Int?, map: String?)

    /// @name Index
    /// Index this field
    declare unique model field decorator index(sort: Sort?, length: Int?, map: String?)

    /// @name Unique
    /// Unique index this field
    declare unique model field decorator unique(sort: Sort?, length: Int?, map: String?)

    /// @name Virtual
    /// Specify a virtual field
    declare unique model field decorator virtual

    /// @name Record Previous
    /// Record the previous value for this field
    declare unique model field decorator recordPrevious

    /// @name Input Omissible
    /// When generating clients, the input is always optional
    declare unique model field decorator inputOmissible

    /// @name Outout Omissible
    /// When generating clients, the outout is always optional
    declare unique model field decorator outputOmissible

    /// @name Auto
    /// The field value is automatically set by the underlying database
    declare unique model field decorator auto

    /// @name Auto Increment
    /// The field value is a serial number automatically set by the underlying database
    declare unique model field decorator autoIncrement

    /// @name Default
    /// Specify a default value for this field
    declare unique model field decorator default(value?: FieldType<Self> | Pipeline<Null, FieldType>)

    /// @name Foreign Key
    /// This field is used as foreign key
    declare unique model field decorator foreignKey

    /// @name On Set
    /// This pipeline is triggered when value is set
    declare unique model field decorator onSet(pipeline?: Pipeline<FieldType<Self>?, InputType>)

    /// @name On Save
    /// This pipeline is triggered before the value is saving into the database
    declare unique model field decorator onSave(pipeline?: Pipeline<FieldType<Self>?, FieldType<Self>>)

    /// @name On Output
    /// This pipeline is triggered on output
    declare unique model field decorator onOutput(pipeline?: Pipeline<FieldType<Self>, InputType>)

    /// @name Auth Identity
    /// This field is used as auth identity
    declare unique model field decorator authIdentity

    /// @name Auth By
    /// This field is used as signing in identity checker
    declare unique model field decorator authBy(pipeline?: Pipeline<FieldType<Self>, Ignored>)

    /// @name Queryable
    /// This field can be queried by the client
    declare unique model field decorator queryable

    /// @name Unqueryable
    /// This field can't be queried by the client
    declare unique model field decorator unqueryable

    /// @name Sortable
    /// This field can be sorted by the client
    declare unique model field decorator sortable

    /// @name Unsortable
    /// This field can't be sorted by the client
    declare unique model field decorator unsortable

    /// @name Can Read
    /// Specify the permission checker for read on this field
    declare unique model field decorator canRead(pipeline?: Pipeline<Object<Self>, Ignored>)

    /// @name Can Mutate
    /// Specify the permission checker for write on this field
    declare unique model field decorator canMutate(pipeline?: Pipeline<Object<Self>, Ignored>)

    /// @name Migration
    /// Specify the migration operation for this field
    declare unique model field decorator migration(
        renamed: (String | Vec<String>)?, 
        version: String?, 
        default: FieldType<Self>?,
        priority: Int?
    )

    /// @name Dropped
    /// Specify that this field is dropped
    declare unique model field decorator dropped

    /// @name Relation
    /// Define a model relation
    declare unique model relation decorator relation {
        /// Define a normal relation
        variant(fields: ScalarField<Self>, references: ScalarField<Relation>)
        /// Define a through relation
        variant(through: Model, local: ScalarField<Through>, foreign: ScalarField<Through>)
    }

    /// @name Getter
    /// Define a property with getter
    declare unique model property decorator getter(pipeline?: Pipeline<Object<Self>, FieldType<Self>>)

    /// @name Setter
    /// Define a property with setter
    declare unique model property decorator setter(pipeline?: Pipeline<FieldType<Self>, Ignored>)

    /// @name Cache
    /// Define a cached property, a cached property is saved into the database
    declare unique model property decorator cached

    /// @name Dependencies
    /// Define dependencies for a cached property
    declare unique model property decorator deps(deps?: ScalarField<Self> | ScalarField<Self>[])

    /// @name Index
    /// Define index for this cached property
    declare unique model property decorator index(sort: Sort?, length: Int?, map: String?)

    /// @name Unique
    /// Define unique index for this cached property
    declare unique model property decorator unique(sort: Sort?, length: Int?, map: String?)

    /// @name Add
    /// Add a new numeric value 
    declare pipeline item add {
        variant(value?: Int | Pipeline<InputType, Int>): Int -> Int
        variant(value?: Int64 | Pipeline<InputType, Int64>): Int64 -> Int64
        variant(value?: Float32 | Pipeline<InputType, Float32>): Float32 -> Float32
        variant(value?: Float | Pipeline<InputType, Float>): Float -> Float
        variant(value?: Decimal | Pipeline<InputType, Decimal>): Decimal -> Decimal
    }

    /// @name Sub
    /// Subtract a numeric value 
    declare pipeline item sub {
        variant(value?: Int | Pipeline<InputType, Int>): Int -> Int
        variant(value?: Int64 | Pipeline<InputType, Int64>): Int64 -> Int64
        variant(value?: Float32 | Pipeline<InputType, Float32>): Float32 -> Float32
        variant(value?: Float | Pipeline<InputType, Float>): Float -> Float
        variant(value?: Decimal | Pipeline<InputType, Decimal>): Decimal -> Decimal
    }

    /// @name Mul
    /// Multiply a numeric value 
    declare pipeline item mul {
        variant(value?: Int | Pipeline<InputType, Int>): Int -> Int
        variant(value?: Int64 | Pipeline<InputType, Int64>): Int64 -> Int64
        variant(value?: Float32 | Pipeline<InputType, Float32>): Float32 -> Float32
        variant(value?: Float | Pipeline<InputType, Float>): Float -> Float
        variant(value?: Decimal | Pipeline<InputType, Decimal>): Decimal -> Decimal
    }

    /// @name Div
    /// Divide a numeric value 
    declare pipeline item div {
        variant(value?: Int | Pipeline<InputType, Int>): Int -> Int
        variant(value?: Int64 | Pipeline<InputType, Int64>): Int64 -> Int64
        variant(value?: Float32 | Pipeline<InputType, Float32>): Float32 -> Float32
        variant(value?: Float | Pipeline<InputType, Float>): Float -> Float
        variant(value?: Decimal | Pipeline<InputType, Decimal>): Decimal -> Decimal
    }

    /// @name Mod
    /// Mod a numeric value 
    declare pipeline item mod {
        variant(value?: Int | Pipeline<InputType, Int>): Int -> Int
        variant(value?: Int64 | Pipeline<InputType, Int64>): Int64 -> Int64
    }

    /// @name Floor
    /// Get the floor value
    declare pipeline item floor {
        variant: Float32 -> Float32
        variant: Float -> Float
        variant: Decimal -> Decimal
    }

    /// @name Ceil
    /// Get the ceil value
    declare pipeline item ceil {
        variant: Float32 -> Float32
        variant: Float -> Float
        variant: Decimal -> Decimal
    }

    /// @name Round
    /// Get the rounded value
    declare pipeline item round {
        variant: Float32 -> Float32
        variant: Float -> Float
        variant: Decimal -> Decimal
    }

    /// @name Square Root
    /// Get the square root value
    declare pipeline item sqrt {
        variant: Int -> Int
        variant: Int64 -> Int64
        variant: Float32 -> Float32
        variant: Float -> Float
        variant: Decimal -> Decimal
    }

    /// @name Cube Root
    /// Get the cube root value
    declare pipeline item cbrt {
        variant: Int -> Int
        variant: Int64 -> Int64
        variant: Float32 -> Float32
        variant: Float -> Float
        variant: Decimal -> Decimal
    }

    /// @name Absolute Value
    /// Get the absolute value
    declare pipeline item abs {
        variant: Int -> Int
        variant: Int64 -> Int64
        variant: Float32 -> Float32
        variant: Float -> Float
        variant: Decimal -> Decimal
    }

    /// @name Power
    /// Get the power value
    declare pipeline item pow {
        variant(value?: Int | Pipeline<InputType, Int>): Int -> Int
        variant(value?: Int | Pipeline<InputType, Int>): Int64 -> Int64
        variant(value?: Int | Pipeline<InputType, Int>): Float32 -> Float32
        variant(value?: Int | Pipeline<InputType, Int>): Float -> Float
        variant(value?: Int | Pipeline<InputType, Int>): Decimal -> Decimal
    }

    /// @name Root
    /// Get the root value
    declare pipeline item root {
        variant(value?: Int | Pipeline<InputType, Int>): Int -> Int
        variant(value?: Int | Pipeline<InputType, Int>): Int64 -> Int64
        variant(value?: Int | Pipeline<InputType, Int>): Float32 -> Float32
        variant(value?: Int | Pipeline<InputType, Int>): Float -> Float
        variant(value?: Int | Pipeline<InputType, Int>): Decimal -> Decimal
    }

    /// @name Min
    /// If current value is less than `value`, set the value to `value`
    declare pipeline item min {
        variant(value?: Int | Pipeline<InputType, Int>): Int -> Int
        variant(value?: Int64 | Pipeline<InputType, Int64>): Int64 -> Int64
        variant(value?: Float32 | Pipeline<InputType, Float32>): Float32 -> Float32
        variant(value?: Float | Pipeline<InputType, Float>): Float -> Float
        variant(value?: Decimal | Pipeline<InputType, Decimal>): Decimal -> Decimal
    }

    /// @name Max
    /// If current value is greater than `value`, set the value to `value`
    declare pipeline item max {
        variant(value?: Int | Pipeline<InputType, Int>): Int -> Int
        variant(value?: Int64 | Pipeline<InputType, Int64>): Int64 -> Int64
        variant(value?: Float32 | Pipeline<InputType, Float32>): Float32 -> Float32
        variant(value?: Float | Pipeline<InputType, Float>): Float -> Float
        variant(value?: Decimal | Pipeline<InputType, Decimal>): Decimal -> Decimal
    }

    /// @name Is Even
    /// throws if current value is not even
    declare pipeline item isEven {
        variant: Int -> Int
        variant: Int64 -> Int64
    }

    /// @name Is Odd
    /// throws if current value is not odd
    declare pipeline item isOdd {
        variant: Int -> Int
        variant: Int64 -> Int64
    }

    /// @name randomInt
    /// generate a random integer
    declare pipeline item randomInt {
        variant(range?: Range<Int>): Ignored -> Int
        variant(length?: Int): Ignored -> Int
    }

    /// @name randomFloat
    /// generate a random float
    declare pipeline item randomFloat(range?: Range<Float>): Ignored -> Float

    /// @name CUID
    /// generate a CUID
    declare pipeline item cuid: Ignored -> String

    /// @name UUID
    /// generate a UUID
    declare pipeline item uuid: Ignored -> String

    /// @name slug
    /// generate a slug
    declare pipeline item slug: Ignored -> String

    /// @name Random Digits
    /// generate a random digits string
    declare pipeline item randomDigits(len?: Int): Ignored -> String

    /// @name Ellipsis
    /// truncate string with ellipsis
    declare pipeline item ellipsis(ellipsis?: String, width?: Int | Pipeline<InputType, Int>): String -> String

    declare pipeline item padEnd(width?: Int | Pipeline<InputType, Int>, char?: String): String -> String

    declare pipeline item padStart(width?: Int | Pipeline<InputType, Int>, char?: String): String -> String

    declare pipeline item regexReplace(format?: RegExp, substitute?: String): String -> String

    declare pipeline item split(separator?: String | Pipeline<InputType, String>): String -> String[]

    declare pipeline item trim: String -> String

    declare pipeline item toWordCase: String -> String

    declare pipeline item toLowerCase: String -> String

    declare pipeline item toUpperCase: String -> String

    declare pipeline item toSentenceCase: String -> String

    declare pipeline item toTitleCase: String -> String

    declare pipeline item hasPrefix(prefix?: String | Pipeline<InputType, String>): String -> String

    declare pipeline item hasSuffix(suffix?: String | Pipeline<InputType, String>): String -> String

    declare pipeline item isPrefixOf(value?: String | Pipeline<InputType, String>): String -> String

    declare pipeline item isSuffixOf(value?: String | Pipeline<InputType, String>): String -> String

    declare pipeline item isAlphabetic: String -> String

    declare pipeline item isAlphanumeric: String -> String

    declare pipeline item isEmail: String -> String

    declare pipeline item isHexColor: String -> String

    declare pipeline item isNumeric: String -> String

    declare pipeline item isSecurePassword: String -> String

    declare pipeline item regexMatch(regex?: RegExp): String -> String

    declare pipeline item identity: Ignored -> Object<Unknown>?

    declare pipeline item print<T>(label?: String?): T -> T where T: Any

    declare pipeline item bcryptSalt: String -> String

    declare pipeline item bcryptVerify(value?: Pipeline<InputType, String>): String -> String

    declare pipeline item when<T>(action?: Action, pipeline?: Pipeline<InputType, T>): Ignored -> T

    declare pipeline item append {
        variant(value?: String | Pipeline<InputType, String>): String -> String
        variant<T>(value?: T | Pipeline<InputType, T>): T[] -> T[]
    }

    declare pipeline item prepend {
        variant(value?: String | Pipeline<InputType, String>): String -> String
        variant<T>(value?: T | Pipeline<InputType, T>): T[] -> T[]
    }

    declare pipeline item getLength {
        variant: String -> Int
        variant<T>: T[] -> Int
    }

    declare pipeline item hasLength {
        variant(len?: Int): String -> Int
        variant(range?: Range<Int>): String -> Int
        variant<T>(len?: Int): T[] -> Int
        variant(range?: Range<Int>): T[] -> Int
    }

    declare pipeline item reverse {
        variant: String -> String
        variant<T>: T[] -> T[]
    }

    declare pipeline item truncate {
        variant(maxLen?: Int | Pipeline<InputType, Int>): String -> String
        variant<T>(maxLen?: Int | Pipeline<InputType, Int>): T[] -> T[]
    }

    declare pipeline item now: Ignored -> DateTime

    declare pipeline item today<T>(tz?: Int | Pipeline<T, Int>): T -> Date

    declare pipeline item toDate(tz?: Int | Pipeline<DateTime, Int>): DateTime -> Date

    /// @name Valid
    /// This pipeline item is always valid
    declare pipeline item valid<T>: T -> T

    declare pipeline item invalid<T>: T -> T

    /// @name Passed
    /// When `pipeline` doesn't throw, returns true
    declare pipeline item passed<T>(pipeline?: Pipeline<T, Ignored>): T -> Bool

    declare pipeline item if<T, U>(cond?: Pipeline<T, Ignored>, then: Pipeline<T, U>, else: Pipeline<T, U>?): T -> U

    // or, and, not, all, any

    /// @name Self
    /// Get the current pipeline context object
    declare pipeline item self: Ignored -> Object<Self>

    /// @name Set
    /// Set the value on object or map
    declare pipeline item set {
        variant<T>(key?: String, value?: T): Map<String, T> -> Map<String, T>
        variant<T, K>(key?: K, value?: T[K]): Object<T> -> Object<T> where K: ScalarField<T>, T: Model
    }

    /// @name Get
    /// Get the value on object or map
    declare pipeline item get {
        variant<T>(key?: String): Map<String, T> -> T?
        variant<T, K>(key?: K): Object<T> -> T[K]? where K: ScalarField<T>, T: Model
    }

    /// @name Previous
    /// Get the previous object value
    declare pipeline item previous<T, K>(key?: K): Object<T> -> T[K]

    /// @name Assign
    /// Assign value to key on context object
    declare pipeline item assign<T, K, U>(key?: K, value?: T[K] | Pipeline<U, T[K]>): U -> U where K: ScalarField<T>, T: Model

    // isA, is

    // // value
    // objects.insert("eq".to_owned(), eq);
    // objects.insert("gt".to_owned(), gt);
    // objects.insert("gte".to_owned(), gte);
    // objects.insert("exists".to_owned(), exists);
    // objects.insert("isFalse".to_owned(), is_false);
    // objects.insert("isNull".to_owned(), is_null);
    // objects.insert("isTrue".to_owned(), is_true);
    // objects.insert("lt".to_owned(), lt);
    // objects.insert("lte".to_owned(), lte);
    // objects.insert("neq".to_owned(), neq);
    // objects.insert("oneOf".to_owned(), one_of);
    // // vector
    // objects.insert("join".to_owned(), join);
    // objects.insert("at".to_owned(), item_at);
    // objects.insert("filter".to_owned(), filter);
    // objects.insert("map".to_owned(), map);        
}